"use strict";(self.webpackChunkapp=self.webpackChunkapp||[]).push([[7731],{7731:(nt,ve,L)=>{L.d(ve,{b:()=>tt});var u=L(467);const p=new TextEncoder,K=new TextDecoder;function C(...e){const t=e.reduce((o,{length:a})=>o+a,0),r=new Uint8Array(t);let n=0;for(const o of e)r.set(o,n),n+=o.length;return r}const F=e=>(e=>{let t=e;"string"==typeof t&&(t=p.encode(t));const n=[];for(let o=0;o<t.length;o+=32768)n.push(String.fromCharCode.apply(null,t.subarray(o,o+32768)));return btoa(n.join(""))})(e).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),A=e=>{let t=e;t instanceof Uint8Array&&(t=K.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return(e=>{const t=atob(e),r=new Uint8Array(t.length);for(let n=0;n<t.length;n++)r[n]=t.charCodeAt(n);return r})(t)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}};class f extends Error{static get code(){return"ERR_JOSE_GENERIC"}constructor(t){var r;super(t),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,null===(r=Error.captureStackTrace)||void 0===r||r.call(Error,this,this.constructor)}}class _ extends f{static get code(){return"ERR_JWT_CLAIM_VALIDATION_FAILED"}constructor(t,r,n="unspecified",o="unspecified"){super(t),this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=n,this.reason=o,this.payload=r}}class oe extends f{static get code(){return"ERR_JWT_EXPIRED"}constructor(t,r,n="unspecified",o="unspecified"){super(t),this.code="ERR_JWT_EXPIRED",this.claim=n,this.reason=o,this.payload=r}}class Pe extends f{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class w extends f{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class c extends f{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class B extends f{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}static get code(){return"ERR_JWT_INVALID"}}class Re extends f{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}function ie(e,t){const r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:e.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case"EdDSA":return{name:t.name};default:throw new w(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}const O=crypto,ae=e=>e instanceof CryptoKey,se=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if("number"!=typeof r||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};function l(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function E(e,t){return e.name===t}function D(e){return parseInt(e.name.slice(4),10)}function Ie(e,t,...r){switch(t){case"HS256":case"HS384":case"HS512":{if(!E(e.algorithm,"HMAC"))throw l("HMAC");const n=parseInt(t.slice(2),10);if(D(e.algorithm.hash)!==n)throw l(`SHA-${n}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!E(e.algorithm,"RSASSA-PKCS1-v1_5"))throw l("RSASSA-PKCS1-v1_5");const n=parseInt(t.slice(2),10);if(D(e.algorithm.hash)!==n)throw l(`SHA-${n}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!E(e.algorithm,"RSA-PSS"))throw l("RSA-PSS");const n=parseInt(t.slice(2),10);if(D(e.algorithm.hash)!==n)throw l(`SHA-${n}`,"algorithm.hash");break}case"EdDSA":if("Ed25519"!==e.algorithm.name&&"Ed448"!==e.algorithm.name)throw l("Ed25519 or Ed448");break;case"ES256":case"ES384":case"ES512":{if(!E(e.algorithm,"ECDSA"))throw l("ECDSA");const n=function We(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}(t);if(e.algorithm.namedCurve!==n)throw l(n,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}!function ce(e,t){if(t.length&&!t.some(r=>e.usages.includes(r))){let r="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const n=t.pop();r+=`one of ${t.join(", ")}, or ${n}.`}else r+=2===t.length?`one of ${t[0]} or ${t[1]}.`:`${t[0]}.`;throw new TypeError(r)}}(e,r)}function de(e,t,...r){if((r=r.filter(Boolean)).length>2){const o=r.pop();e+=`one of type ${r.join(", ")}, or ${o}.`}else e+=2===r.length?`one of type ${r[0]} or ${r[1]}.`:`of type ${r[0]}.`;if(null==t)e+=` Received ${t}`;else if("function"==typeof t&&t.name)e+=` Received function ${t.name}`;else if("object"==typeof t&&null!=t){var n;null!==(n=t.constructor)&&void 0!==n&&n.name&&(e+=` Received an instance of ${t.constructor.name}`)}return e}const ue=(e,...t)=>de("Key must be ",e,...t);function le(e,t,...r){return de(`Key for the ${e} algorithm must be `,t,...r)}const fe=e=>!!ae(e)||"KeyObject"===(null==e?void 0:e[Symbol.toStringTag]),N=["CryptoKey"];function T(e){if(!function Je(e){return"object"==typeof e&&null!==e}(e)||"[object Object]"!==Object.prototype.toString.call(e))return!1;if(null===Object.getPrototypeOf(e))return!0;let t=e;for(;null!==Object.getPrototypeOf(t);)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}function P(e){return T(e)&&"string"==typeof e.kty}const he=function(){var e=(0,u.A)(function*(t){var r,n;if(!t.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:o,keyUsages:a}=function Oe(e){let t,r;switch(e.kty){case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new w('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new w('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"OKP":switch(e.alg){case"EdDSA":t={name:e.crv},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new w('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;default:throw new w('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}(t),i=[o,null!==(r=t.ext)&&void 0!==r&&r,null!==(n=t.key_ops)&&void 0!==n?n:a],s={...t};return delete s.alg,delete s.use,O.subtle.importKey("jwk",s,...i)});return function(r){return e.apply(this,arguments)}}(),pe=e=>A(e);let R,W;const ye=e=>"KeyObject"===(null==e?void 0:e[Symbol.toStringTag]),$=function(){var e=(0,u.A)(function*(t,r,n,o,a=!1){let i=t.get(r);if(null!=i&&i[o])return i[o];const s=yield he({...n,alg:o});return a&&Object.freeze(r),i?i[o]=s:t.set(r,{[o]:s}),s});return function(r,n,o,a){return e.apply(this,arguments)}}(),me={normalizePublicKey:(e,t)=>{if(ye(e)){let r=e.export({format:"jwk"});return delete r.d,delete r.dp,delete r.dq,delete r.p,delete r.q,delete r.qi,r.k?pe(r.k):(W||(W=new WeakMap),$(W,e,r,t))}return P(e)?e.k?A(e.k):(W||(W=new WeakMap),$(W,e,e,t,!0)):e},normalizePrivateKey:(e,t)=>{if(ye(e)){let r=e.export({format:"jwk"});return r.k?pe(r.k):(R||(R=new WeakMap),$(R,e,r,t))}return P(e)?e.k?A(e.k):(R||(R=new WeakMap),$(R,e,e,t,!0)):e}};function _e(e,t,r){return X.apply(this,arguments)}function X(){return(X=(0,u.A)(function*(e,t,r){if("sign"===r&&(t=yield me.normalizePrivateKey(t,e)),"verify"===r&&(t=yield me.normalizePublicKey(t,e)),ae(t))return Ie(t,e,r),t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(ue(t,...N));return O.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[r])}throw new TypeError(ue(t,...N,"Uint8Array","JSON Web Key"))})).apply(this,arguments)}const De=function(){var e=(0,u.A)(function*(t,r,n){const o=yield _e(t,r,"sign");se(t,o);const a=yield O.subtle.sign(ie(t,o.algorithm),o,n);return new Uint8Array(a)});return function(r,n,o){return e.apply(this,arguments)}}(),ge=(...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let r;for(const n of t){const o=Object.keys(n);if(r&&0!==r.size)for(const a of o){if(r.has(a))return!1;r.add(a)}else r=new Set(o)}return!0},I=e=>null==e?void 0:e[Symbol.toStringTag],z=(e,t,r)=>{var n,o;if(void 0!==t.use&&"sig"!==t.use)throw new TypeError("Invalid key for this operation, when present its use must be sig");if(void 0!==t.key_ops&&!0!==(null===(n=(o=t.key_ops).includes)||void 0===n?void 0:n.call(o,r)))throw new TypeError(`Invalid key for this operation, when present its key_ops must include ${r}`);if(void 0!==t.alg&&t.alg!==e)throw new TypeError(`Invalid key for this operation, when present its alg must be ${e}`);return!0};function Se(e,t,r,n){t.startsWith("HS")||"dir"===t||t.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(t)?((e,t,r,n)=>{if(!(t instanceof Uint8Array)){if(n&&P(t)){if(function Ce(e){return P(e)&&"oct"===e.kty&&"string"==typeof e.k}(t)&&z(e,t,r))return;throw new TypeError('JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present')}if(!fe(t))throw new TypeError(le(e,t,...N,"Uint8Array",n?"JSON Web Key":null));if("secret"!==t.type)throw new TypeError(`${I(t)} instances for symmetric algorithms must be of type "secret"`)}})(t,r,n,e):((e,t,r,n)=>{if(n&&P(t))switch(r){case"sign":if(function He(e){return"oct"!==e.kty&&"string"==typeof e.d}(t)&&z(e,t,r))return;throw new TypeError("JSON Web Key for this operation be a private JWK");case"verify":if(function xe(e){return"oct"!==e.kty&&typeof e.d>"u"}(t)&&z(e,t,r))return;throw new TypeError("JSON Web Key for this operation be a public JWK")}if(!fe(t))throw new TypeError(le(e,t,...N,n?"JSON Web Key":null));if("secret"===t.type)throw new TypeError(`${I(t)} instances for asymmetric algorithms must not be of type "secret"`);if("sign"===r&&"public"===t.type)throw new TypeError(`${I(t)} instances for asymmetric algorithm signing must be of type "private"`);if("decrypt"===r&&"public"===t.type)throw new TypeError(`${I(t)} instances for asymmetric algorithm decryption must be of type "private"`);if(t.algorithm&&"verify"===r&&"private"===t.type)throw new TypeError(`${I(t)} instances for asymmetric algorithm verifying must be of type "public"`);if(t.algorithm&&"encrypt"===r&&"private"===t.type)throw new TypeError(`${I(t)} instances for asymmetric algorithm encryption must be of type "public"`)})(t,r,n,e)}Se.bind(void 0,!1);const k=Se.bind(void 0,!0),we=function Me(e,t,r,n,o){if(void 0!==o.crit&&void 0===(null==n?void 0:n.crit))throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||void 0===n.crit)return new Set;if(!Array.isArray(n.crit)||0===n.crit.length||n.crit.some(i=>"string"!=typeof i||0===i.length))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let a;a=void 0!==r?new Map([...Object.entries(r),...t.entries()]):t;for(const i of n.crit){if(!a.has(i))throw new w(`Extension Header Parameter "${i}" is not recognized`);if(void 0===o[i])throw new e(`Extension Header Parameter "${i}" is missing`);if(a.get(i)&&void 0===n[i])throw new e(`Extension Header Parameter "${i}" MUST be integrity protected`)}return new Set(n.crit)};class Ue{constructor(t){if(!(t instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=t}setProtectedHeader(t){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=t,this}setUnprotectedHeader(t){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=t,this}sign(t,r){var n=this;return(0,u.A)(function*(){if(!n._protectedHeader&&!n._unprotectedHeader)throw new c("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!ge(n._protectedHeader,n._unprotectedHeader))throw new c("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const o={...n._protectedHeader,...n._unprotectedHeader};let i=!0;if(we(c,new Map([["b64",!0]]),null==r?void 0:r.crit,n._protectedHeader,o).has("b64")&&(i=n._protectedHeader.b64,"boolean"!=typeof i))throw new c('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:s}=o;if("string"!=typeof s||!s)throw new c('JWS "alg" (Algorithm) Header Parameter missing or invalid');k(s,t,"sign");let h,d=n._payload;i&&(d=p.encode(F(d))),h=p.encode(n._protectedHeader?F(JSON.stringify(n._protectedHeader)):"");const g=C(h,p.encode("."),d),y=yield De(s,t,g),S={signature:F(y),payload:""};return i&&(S.payload=K.decode(d)),n._unprotectedHeader&&(S.header=n._unprotectedHeader),n._protectedHeader&&(S.protected=K.decode(h)),S})()}}class Le{constructor(t){this._flattened=new Ue(t)}setProtectedHeader(t){return this._flattened.setProtectedHeader(t),this}sign(t,r){var n=this;return(0,u.A)(function*(){const o=yield n._flattened.sign(t,r);if(void 0===o.payload)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${o.protected}.${o.payload}.${o.signature}`})()}}const b=e=>Math.floor(e.getTime()/1e3),Fe=/^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i,H=e=>{const t=Fe.exec(e);if(!t||t[4]&&t[1])throw new TypeError("Invalid time period format");const r=parseFloat(t[2]);let o;switch(t[3].toLowerCase()){case"sec":case"secs":case"second":case"seconds":case"s":o=Math.round(r);break;case"minute":case"minutes":case"min":case"mins":case"m":o=Math.round(60*r);break;case"hour":case"hours":case"hr":case"hrs":case"h":o=Math.round(3600*r);break;case"day":case"days":case"d":o=Math.round(86400*r);break;case"week":case"weeks":case"w":o=Math.round(604800*r);break;default:o=Math.round(31557600*r)}return"-"===t[1]||"ago"===t[4]?-o:o};function v(e,t){if(!Number.isFinite(t))throw new TypeError(`Invalid ${e} input`);return t}class Be{constructor(t={}){if(!T(t))throw new TypeError("JWT Claims Set MUST be an object");this._payload=t}setIssuer(t){return this._payload={...this._payload,iss:t},this}setSubject(t){return this._payload={...this._payload,sub:t},this}setAudience(t){return this._payload={...this._payload,aud:t},this}setJti(t){return this._payload={...this._payload,jti:t},this}setNotBefore(t){return this._payload="number"==typeof t?{...this._payload,nbf:v("setNotBefore",t)}:t instanceof Date?{...this._payload,nbf:v("setNotBefore",b(t))}:{...this._payload,nbf:b(new Date)+H(t)},this}setExpirationTime(t){return this._payload="number"==typeof t?{...this._payload,exp:v("setExpirationTime",t)}:t instanceof Date?{...this._payload,exp:v("setExpirationTime",b(t))}:{...this._payload,exp:b(new Date)+H(t)},this}setIssuedAt(t){return this._payload=typeof t>"u"?{...this._payload,iat:b(new Date)}:t instanceof Date?{...this._payload,iat:v("setIssuedAt",b(t))}:"string"==typeof t?{...this._payload,iat:v("setIssuedAt",b(new Date)+H(t))}:{...this._payload,iat:v("setIssuedAt",t)},this}}class M extends Be{setProtectedHeader(t){return this._protectedHeader=t,this}sign(t,r){var n=this;return(0,u.A)(function*(){var o;const a=new Le(p.encode(JSON.stringify(n._payload)));if(a.setProtectedHeader(n._protectedHeader),Array.isArray(null===(o=n._protectedHeader)||void 0===o?void 0:o.crit)&&n._protectedHeader.crit.includes("b64")&&!1===n._protectedHeader.b64)throw new B("JWTs MUST NOT use unencoded payload");return a.sign(t,r)})()}}const Xe=function(){var e=(0,u.A)(function*(t,r,n,o){const a=yield _e(t,r,"verify");se(t,a);const i=ie(t,a.algorithm);try{return yield O.subtle.verify(i,a,n,o)}catch{return!1}});return function(r,n,o,a){return e.apply(this,arguments)}}(),ze=(e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some(r=>"string"!=typeof r)))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};function j(){return(j=(0,u.A)(function*(e,t){if(!T(e))throw new TypeError("JWK must be an object");switch(t||(t=e.alg),e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return A(e.k);case"RSA":if(void 0!==e.oth)throw new w('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return he({...e,alg:t});default:throw new w('Unsupported "kty" (Key Type) Parameter value')}})).apply(this,arguments)}function ee(){return ee=(0,u.A)(function*(e,t,r){var n;if(!T(e))throw new c("Flattened JWS must be an object");if(void 0===e.protected&&void 0===e.header)throw new c('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==e.protected&&"string"!=typeof e.protected)throw new c("JWS Protected Header incorrect type");if(void 0===e.payload)throw new c("JWS Payload missing");if("string"!=typeof e.signature)throw new c("JWS Signature missing or incorrect type");if(void 0!==e.header&&!T(e.header))throw new c("JWS Unprotected Header incorrect type");let o={};if(e.protected)try{const rt=A(e.protected);o=JSON.parse(K.decode(rt))}catch{throw new c("JWS Protected Header is invalid")}if(!ge(o,e.header))throw new c("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const a={...o,...e.header};let s=!0;if(we(c,new Map([["b64",!0]]),null==r?void 0:r.crit,o,a).has("b64")&&(s=o.b64,"boolean"!=typeof s))throw new c('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:d}=a;if("string"!=typeof d||!d)throw new c('JWS "alg" (Algorithm) Header Parameter missing or invalid');const h=r&&ze("algorithms",r.algorithms);if(h&&!h.has(d))throw new Pe('"alg" (Algorithm) Header Parameter value not allowed');if(s){if("string"!=typeof e.payload)throw new c("JWS Payload must be a string")}else if("string"!=typeof e.payload&&!(e.payload instanceof Uint8Array))throw new c("JWS Payload must be a string or an Uint8Array instance");let g=!1;"function"==typeof t?(t=yield t(o,e),g=!0,k(d,t,"verify"),P(t)&&(t=yield function ke(e,t){return j.apply(this,arguments)}(t,d))):k(d,t,"verify");const y=C(p.encode(null!==(n=e.protected)&&void 0!==n?n:""),p.encode("."),"string"==typeof e.payload?p.encode(e.payload):e.payload);let S,m;try{S=A(e.signature)}catch{throw new c("Failed to base64url decode the signature")}if(!(yield Xe(d,t,S,y)))throw new Re;if(s)try{m=A(e.payload)}catch{throw new c("Failed to base64url decode the payload")}else m="string"==typeof e.payload?p.encode(e.payload):e.payload;const J={payload:m};return void 0!==e.protected&&(J.protectedHeader=o),void 0!==e.header&&(J.unprotectedHeader=e.header),g?{...J,key:t}:J}),ee.apply(this,arguments)}function te(){return te=(0,u.A)(function*(e,t,r){if(e instanceof Uint8Array&&(e=K.decode(e)),"string"!=typeof e)throw new c("Compact JWS must be a string or Uint8Array");const{0:n,1:o,2:a,length:i}=e.split(".");if(3!==i)throw new c("Invalid Compact JWS");const s=yield function Ye(e,t,r){return ee.apply(this,arguments)}({payload:o,protected:n,signature:a},t,r),d={payload:s.payload,protectedHeader:s.protectedHeader};return"function"==typeof t?{...d,key:s.key}:d}),te.apply(this,arguments)}const Ae=e=>e.toLowerCase().replace(/^application\//,""),Qe=(e,t,r={})=>{let n;try{n=JSON.parse(K.decode(t))}catch{}if(!T(n))throw new B("JWT Claims Set must be a top-level JSON object");const{typ:o}=r;if(o&&("string"!=typeof e.typ||Ae(e.typ)!==Ae(o)))throw new _('unexpected "typ" JWT header value',n,"typ","check_failed");const{requiredClaims:a=[],issuer:i,subject:s,audience:d,maxTokenAge:h}=r,g=[...a];void 0!==h&&g.push("iat"),void 0!==d&&g.push("aud"),void 0!==s&&g.push("sub"),void 0!==i&&g.push("iss");for(const m of new Set(g.reverse()))if(!(m in n))throw new _(`missing required "${m}" claim`,n,m,"missing");if(i&&!(Array.isArray(i)?i:[i]).includes(n.iss))throw new _('unexpected "iss" claim value',n,"iss","check_failed");if(s&&n.sub!==s)throw new _('unexpected "sub" claim value',n,"sub","check_failed");if(d&&!((e,t)=>"string"==typeof e?t.includes(e):!!Array.isArray(e)&&t.some(Set.prototype.has.bind(new Set(e))))(n.aud,"string"==typeof d?[d]:d))throw new _('unexpected "aud" claim value',n,"aud","check_failed");let y;switch(typeof r.clockTolerance){case"string":y=H(r.clockTolerance);break;case"number":y=r.clockTolerance;break;case"undefined":y=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate:S}=r,U=b(S||new Date);if((void 0!==n.iat||h)&&"number"!=typeof n.iat)throw new _('"iat" claim must be a number',n,"iat","invalid");if(void 0!==n.nbf){if("number"!=typeof n.nbf)throw new _('"nbf" claim must be a number',n,"nbf","invalid");if(n.nbf>U+y)throw new _('"nbf" claim timestamp check failed',n,"nbf","check_failed")}if(void 0!==n.exp){if("number"!=typeof n.exp)throw new _('"exp" claim must be a number',n,"exp","invalid");if(n.exp<=U-y)throw new oe('"exp" claim timestamp check failed',n,"exp","check_failed")}if(h){const m=U-n.iat;if(m-y>("number"==typeof h?h:H(h)))throw new oe('"iat" claim timestamp check failed (too far in the past)',n,"iat","check_failed");if(m<0-y)throw new _('"iat" claim timestamp check failed (it should be in the past)',n,"iat","check_failed")}return n};function re(){return re=(0,u.A)(function*(e,t,r){var n;const o=yield function qe(e,t,r){return te.apply(this,arguments)}(e,t,r);if(null!==(n=o.protectedHeader.crit)&&void 0!==n&&n.includes("b64")&&!1===o.protectedHeader.b64)throw new B("JWTs MUST NOT use unencoded payload");const i={payload:Qe(o.protectedHeader,o.payload,r),protectedHeader:o.protectedHeader};return"function"==typeof t?{...i,key:o.key}:i}),re.apply(this,arguments)}var et=L(4438);let tt=(()=>{var e;class t{constructor(){this.secretKey=(new TextEncoder).encode("BlIp@2024")}generateTokenLogEmail(n,o,a,i){var s=this;return(0,u.A)(function*(){return new M({type_login:n,email:o,password:a,isLogged:i}).setProtectedHeader({alg:"HS256"}).sign(s.secretKey)})()}generateTokenLogPhone(n,o,a){var i=this;return(0,u.A)(function*(){return new M({type_login:n,phone:o,isLogged:a}).setProtectedHeader({alg:"HS256"}).sign(i.secretKey)})()}generateTokenMain(n,o,a){var i=this;return(0,u.A)(function*(){return new M({type_login:n,idUser:o,isLogged:a}).setProtectedHeader({alg:"HS256"}).sign(i.secretKey)})()}generateToken(n){var o=this;return(0,u.A)(function*(){return new M({payload:n}).setProtectedHeader({alg:"HS256"}).sign(o.secretKey)})()}verifyToken(n){var o=this;return(0,u.A)(function*(){try{const{payload:a}=yield function je(e,t,r){return re.apply(this,arguments)}(n,o.secretKey);return a}catch(a){return console.error("Token verification failed:",a),null}})()}}return(e=t).\u0275fac=function(n){return new(n||e)},e.\u0275prov=et.jDH({token:e,factory:e.\u0275fac,providedIn:"root"}),t})()}}]);